## Step 19 - Introduction to Spring Data JPA

In the previous steps, we looked at JDBC, Spring JDBC and JPA. With JPA repository it may be very easy to talk to the database. All that we need to do is to create an EntityManager, and then we can use findById in PersonJpaRepository.class. You can use find, merge, or remove methods to talk to the database. This made it very easy because we don't really need to write any queries, all these queries were generated by hibernate which is the JPA implementation.

However, if you look at this PersonJpaRepository class, you can see that whether this is for Person entity, or let's say there is a [Todo JPA repository](https://github.com/pkainulainen/spring-data-jpa-examples/blob/master/query-methods/src/main/java/net/petrikainulainen/springdata/jpa/todo/RepositoryTodoService.java) which is present, it would look exactly the same as this. So instead of the Person *public List<Person> findAll()* you would have Todo *public List<Todo> findAll()*. But other than that, the logic here in PersonJpaRepository class would still remain completely the same if you replace *Person* by *Todo*, ninety per cent of the work would automatically be done.

Spring Data identified this. It says, ok there is a lot of duplication that happens when we write our repositories (insert, update and delete methods can be simplified in only one). Can we simplify this? Can we make it further easier to define our repositories ?, that's where Spring Data comes in with the concept of predefined repositories. It defines something called a JPA repository for JPA which we can use to create these kinds of methods very easily. So things like findAll, findById, update, insert, deleteById. All of them are predefined inside the JPA repository. So let's look at that in this specific step.

Let's create a new interface, not a class. I'll call this PersonSpringDataRepository and I'll create it in package com.imh.spring.database.databasedemo.springdata, and I have to make this class implement a specific interface. What is the interface that I would need to implement? It's JpaRepository. Actually I would need to say *extends JpaRepository* because our PersonSpringDataRepository class is an interface, and JPA repository is also an interface. And what entity do we want to manage with this? Person, let's define that *extends JpaRepository <Person>*, Person is the entity I would want to manage, and what is the primary key for it? The primary key is an integer. Let's import person in *extends JpaRepository <Person, Integer>* and that's it.

```java
@Repository
public interface PersonSpringDataRepository 
				extends JpaRepository<Person, Integer>{
}
```

What we'll do is, I'll copy the SpringJpaApplication and create another one called SpringDataApplication, and I'll comment out the @SpringBootApplication annotation in SpringJpaApplication so that it's not picked up. So now we have SpringDataApplication which is present in here above, and instead of using the *PersonJpaRepository repository*, what we will do is we would be using a *PersonSpringDataRepository*, let's import it in (see #1). You would see that most of the code works as it is because we have actually followed the conventions which are used by Spring Data when defining our methods.

```
@SpringBootApplication
public class SpringDataApplication implements CommandLineRunner {

	private Logger logger = LoggerFactory.getLogger(this.getClass());

	@Autowired
	PersonSpringDataRepository repository;	//#1

	public static void main(String[] args) {
		SpringApplication.run(SpringDataDemoApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		
		logger.info("User id 10001 -> {}", repository.findById(10001));
		
		logger.info("Inserting -> {}", 
				repository.save(new Person("Tara", "Berlin", new Date())));
		
		logger.info("Update 10003 -> {}", 
				repository.save(new Person(10003, "Pieter", "Utrecht", new Date())));
		
		repository.deleteById(10002);

		logger.info("All users -> {}", repository.findAll());
	}
}
```

In Spring Data there's a method called findById, if you pass the Id, it will be able to get the data for you. However, once a small thing is in Spring Data there are no insert and update methods, very similar to your EntityManager. So EntityManager has only one method. So it's *repository.merge* and inside the data JPA repository, the method is called *repository.save*. So whether you want to do an update or an insert, you have to just say *repository.save*, and you would see that now, within less than a few minutes you were able to implement all the methods using Spring Data JPA Repository. Let's now launch up this SpringDataApplication.

```
Console output:

[2m2020-02-28 22:31:20.251[0;39m [32m INFO[0;39m [35m5217[0;39m [2m---[0;39m [2m[  restartedMain][0;39m [36mc.i.s.d.d.SpringDataApplication         [0;39m [2m:[0;39m Started SpringDataApplication in 2.904 seconds (JVM running for 3.586)
Hibernate: select person0_.id as id1_0_0_, person0_.birth_date as birth_da2_0_0_, person0_.location as location3_0_0_, person0_.name as name4_0_0_ from person person0_ where person0_.id=?
[2m2020-02-28 22:31:20.281[0;39m [32m INFO[0;39m [35m5217[0;39m [2m---[0;39m [2m[  restartedMain][0;39m [36mication$$EnhancerBySpringCGLIB$$1ba1a0af[0;39m [2m:[0;39m User id 10001 -> Optional[Person [id=10001, name=Ranga, location=Hyderabad, birthDate=2020-02-28 00:00:00.0]]
Hibernate: call next value for hibernate_sequence
Hibernate: insert into person (birth_date, location, name, id) values (?, ?, ?, ?)
[2m2020-02-28 22:31:20.297[0;39m [32m INFO[0;39m [35m5217[0;39m [2m---[0;39m [2m[  restartedMain][0;39m [36mication$$EnhancerBySpringCGLIB$$1ba1a0af[0;39m [2m:[0;39m Inserting -> Person [id=1, name=Tara, location=Berlin, birthDate=Fri Feb 28 22:31:20 CET 2020]
Hibernate: select person0_.id as id1_0_0_, person0_.birth_date as birth_da2_0_0_, person0_.location as location3_0_0_, person0_.name as name4_0_0_ from person person0_ where person0_.id=?
Hibernate: update person set birth_date=?, location=?, name=? where id=?
[2m2020-02-28 22:31:20.302[0;39m [32m INFO[0;39m [35m5217[0;39m [2m---[0;39m [2m[  restartedMain][0;39m [36mication$$EnhancerBySpringCGLIB$$1ba1a0af[0;39m [2m:[0;39m Update 10003 -> Person [id=10003, name=Pieter, location=Utrecht, birthDate=Fri Feb 28 22:31:20 CET 2020]
Hibernate: select person0_.id as id1_0_0_, person0_.birth_date as birth_da2_0_0_, person0_.location as location3_0_0_, person0_.name as name4_0_0_ from person person0_ where person0_.id=?
Hibernate: delete from person where id=?
Hibernate: select person0_.id as id1_0_, person0_.birth_date as birth_da2_0_, person0_.location as location3_0_, person0_.name as name4_0_ from person person0_
[2m2020-02-28 22:31:20.326[0;39m [32m INFO[0;39m [35m5217[0;39m [2m---[0;39m [2m[  restartedMain][0;39m [36mication$$EnhancerBySpringCGLIB$$1ba1a0af[0;39m [2m:[0;39m All users -> [Person [id=1, name=Tara, location=Berlin, birthDate=2020-02-28 22:31:20.282], Person [id=10001, name=Ranga, location=Hyderabad, birthDate=2020-02-28 00:00:00.0], Person [id=10003, name=Pieter, location=Utrecht, birthDate=2020-02-28 22:31:20.297]]
```

Now you see that there is no change in the result compared to what was present when we were using the JPA repository. So at the end, we have these three rows printed. 

Over the course of the last few steps, what we did was we took the entire journey. We started with JDBC, we moved to JPA, and now we made use of SpringDataJPA. We created a repository with it, and we saw how everything becomes much easier. So with Spring Data all that you need to define is your entities and your interfaces. Once you've defined them, it becomes very easy to manage your entities and talk to your database.

**Note.** Make sure that you're launching up SpringDataApplication and not SpringJdbcApplication or SpringJpaApplication, because the other ones the @SpringBootApplication annotation is commented, and they might give you an error when you tried to start them up.

## Complete Code Example

##### /src/main/java/com/imh/spring/database/databasedemo/SpringDataApplication.java

```java
package com.imh.spring.database.databasedemo;

import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import com.imh.spring.database.databasedemo.entity.Person;
import com.imh.spring.database.databasedemo.springdata.PersonSpringDataRepository;

@SpringBootApplication
public class SpringDataApplication implements CommandLineRunner {

	private Logger logger = LoggerFactory.getLogger(this.getClass());

	@Autowired
	PersonSpringDataRepository repository;

	public static void main(String[] args) {
		SpringApplication.run(SpringDataApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		
		logger.info("User id 10001 -> {}", repository.findById(10001));
		
		logger.info("Inserting -> {}", 
				repository.save(new Person("Tara", "Berlin", new Date())));
		
		logger.info("Update 10003 -> {}", 
				repository.save(new Person(10003, "Pieter", "Utrecht", new Date())));
		
		repository.deleteById(10002);

		logger.info("All users -> {}", repository.findAll());
	}
}
```

---

##### /src/main/java/com/imh/spring/database/databasedemo/springdata/PersonSpringDataRepository.java

```java
package com.imh.spring.database.databasedemo.springdata;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.imh.spring.database.databasedemo.entity.Person;

@Repository
public interface PersonSpringDataRepository 
				extends JpaRepository<Person, Integer>{
}
```